//
// C++ Implementation: pcplugentity
//
// Description: 
//
//
// Author: Štefan Sakalík <rabbit64@users.berlios.de>, (C) 2008
//
// Copyright: See COPYING file that comes with this distribution
//
//

#include <dlfcn.h>
#include <string>

#include "misc/dbgprint.h"
#include "core/pcpacketcenter.h"
#include "core/pcplugentity.h"

/*! \class PCPlugEntity
 *  \brief Interface with PPA Proxy
 *  Main idea of this class is to provide {send -> [ rreceive -> rsend ] -> receive} transaction.
 *  App sends data to plugin, plugin receives a fn. call.
 *  It responds and finally, application receives an answer.
 *
 *  Memory allocation notes:
 *  \TODO: use smart pointers?
 *  \TODO: alloc/dealloc responsibility
 *  \TODO: protocol: quit functions, pipe, proxy and plugin loc. in protocol. => less exec parameters.
 *  *send functions request 
 *  *receive functions allocate data
 */

/*! \brief Called from app to run a plugin
 *  Create a new process, estabilish communication channels.
 *  \param execPath Path to PPACoreExec (plugin handler)
 *  \param proxyPath Path to Proxy library (same as the caller's)
 *  \param pluginPath Path to the plugin to be executed
 */
PCPlugEntity::PCPlugEntity(char* execPath, char* proxyPath, char* pluginPath)
{
	opIdArrayLength = 0;
	bIsPlugCreator = true;

	pipeCtrl = new PCPipeCtrl();
	pipeCtrl -> setAutoDel(true);

	procCtrl = new PCProcCtrl();
	procCtrl->newProcess(execPath, pipeCtrl->getInPipe(), pipeCtrl->getOutPipe(), proxyPath, pluginPath);
	pipeCtrl->openWritePipe();
}

/*! \brief Called from main for Plugin to estabilish a communication with app
 *  \param pipeIn input pipe
 *  \param pipeOut output pipe
 */
PCPlugEntity::PCPlugEntity(char* pipeIn, char* pipeOut)
{
	opIdArrayLength = 0;
	bIsPlugCreator = false;

	pipeCtrl = new PCPipeCtrl(pipeIn, pipeOut);
	pipeCtrl->openWritePipe();
	
}

/*! \brief Request (app->plugin) function call, app side
 *  Sends data to plugin. The plugin should respond.
 *  \param data raw data
 *  \param dataLen
 *  \return operation ID, unique for plugin transaction
 */
int PCPlugEntity::send(char* data, int dataLen) {
	char* headerData; int headerLen;
	int opId = genOpId();

	PCPacketCenter::createHeader(0, opId, dataLen, headerData, headerLen);
	pipeCtrl->send(headerData, headerLen);
	pipeCtrl->send(data, dataLen);

	delete [] headerData;

	return opId;
}

/*! \brief Request (app->plugin) function return, app side
 *  Reads data from plugin.
 *  \param opId operation ID, returned from 'send'
 *  \param data raw data
 *  \param dataLen
 */
void PCPlugEntity::receive(int opId, char*& data, int& dataLen) {
	char* headerData = new char[PCPacketCenter::getHeaderLength()];
	pipeCtrl->receive(headerData, PCPacketCenter::getHeaderLength());

	int packetType, recvOpId;
	// WARNING: data points to UNUSABLE memory block
	PCPacketCenter::parseHeader(headerData, packetType, recvOpId, data, dataLen);

	if(opId != recvOpId) {	// todo
		dbgPrint(2,"IMPL ERROR: opId mismatch / receive");
	}
	delOpId(recvOpId);

	data = new char[dataLen];		// TODO: memory leak
	pipeCtrl->receive(data, dataLen);

	delete [] headerData;
}

/*! \brief Request (app->plugin) function call, plugin side
 *  Reads data from plugin.
 *  \param data raw data
 *  \param dataLen
 *  \return opId operation ID, generated in 'send'
 */
int PCPlugEntity::rreceive(char*& data, int& dataLen) {
	char* headerData = new char[PCPacketCenter::getHeaderLength()];
	pipeCtrl->receive(headerData, PCPacketCenter::getHeaderLength());

	int packetType, opId;
	// WARNING: data points to UNUSABLE memory block
	PCPacketCenter::parseHeader(headerData, packetType, opId, data, dataLen);
	addOpId(opId);

	data = new char[dataLen];	// TODO: memory leak
	pipeCtrl->receive(data, dataLen);

	delete [] headerData;
	return opId;
}

/*! \brief Request (app->plugin) function return, plugin side
 *  Sends data to app.
 *  \param data raw data
 *  \param dataLen
 *  \param opId operation ID, returned from 'send'
 */
void PCPlugEntity::rsend(char* data, int dataLen, int opId) {
	delOpId(opId);

	char* headerData; int headerLen;

	PCPacketCenter::createHeader(0, opId, dataLen, headerData, headerLen);
	pipeCtrl->send(headerData, headerLen);
	pipeCtrl->send(data, dataLen);

	delete [] headerData;
}

/*! \brief add new operation ID
 *  Called from *rreceive functions, when operation ID was generated by different entity.
 *  \param opId operation ID
 */
void PCPlugEntity::addOpId(int opId) {
	dbgPrint(0, "adding op id %d", opId);
	if(opIdArrayLength)
		dbgPrint(2,"IMPL ERROR: opId >0");

	opIdArrayLength = 1;
	opIdArray[0] = opId;
}

/*! \brief generate new operation ID
 *  Called from [^r]*send functions, when 'invoking' function.
 *  \return operation ID
 */
int PCPlugEntity::genOpId() {
	if(opIdArrayLength)
		dbgPrint(2,"IMPL ERROR: opId >0");

	opIdArrayLength = 1; 
	opIdArray[0] = 1;
	return 1;
}

/*! \brief delete operation ID
 *  Called from *rsend, [^r]*receive functions. End of transaction cycle.
 *  \return operation ID
 */
void PCPlugEntity::delOpId(int opId) {
	if(opIdArrayLength > 1)
		dbgPrint(2,"IMPL ERROR: opId >1");

	if(opId != opIdArray[0])
		dbgPrint(2,"PCPlugEntity::delOpId(%d) opId not found", opId);

	opIdArrayLength = 0;
}

/*! \brief destructor
 *  \TODO: implementation
 */
PCPlugEntity::~PCPlugEntity()
{
	if(bIsPlugCreator) {
		pipeCtrl->setAutoDel(true);
		//send("qu(PCDELROUTINE)\n");
	}

	delete pipeCtrl;
}

/*! \brief PPA Proxy layer interface function
 *  Creates new PCPlugEntity object, and passes reference back to caller.
 *  \TODO: mem. responsibility
 *  \param proxyPath pass to PCPlugEntity
 *  \param plugPath pass to PCPlugEntity
 */
extern "C" PCPlugEntity* createPlugin(char* proxyPath, char* plugPath) {
	char execPath[] = EXEC_PATH; 
	return new PCPlugEntity(execPath, proxyPath, plugPath);
}

/*! \brief Plugin execution entry point
 *  \param argc must be 5
 *  \param argv: strings in this order: PipeIn, PipeOut, ProxyLibPath, PluginLibPath
 */
int main(int argc, char ** argv)
{
	if(argc != 5) {
		dbgPrint(2,"Successful init: %s %s", argv[1],argv[2]);
		return 1;
	}
	else {
		dbgPrint(0,"Successful init: %s %s", argv[1],argv[2]);
	}
	
	PCPlugEntity ent(argv[1],argv[2]);

	void* proxyLibHandle = dlopen(argv[3], RTLD_NOW);
	if(!proxyLibHandle)
		dbgPrint(2,"core::main can't open proxy lib, %s", argv[3]);

	typedef void (*MainLoopType) (PCPlugEntity* ent);
	MainLoopType mainLoopPtr = (MainLoopType)dlsym(proxyLibHandle, "mainLoop");
	if(!mainLoopPtr)
		dbgPrint(2,"core::main can't find mainLoopPtr symbol");

	mainLoopPtr(&ent);
	dlclose(proxyLibHandle);
	return 0;
}
